title: Dissecting the Liberated Pixel Cup Demo
---
categories:
---
author: lunpa
---
body:

![](dissecting_lpcd.png)

### ABSTRACT

The [Liberated Pixel Cup Demo](http://lpc.opengameart.org/static/lpc-style-guide/demo.html) (LPCD) was written by yours truly over the course of two weeks, prior to the art phase of the Liberated Pixel Cup contest. The demo had several intended purposes. First, to test the usability of the base tile set for building levels. Second, to show character sprites interacting with environments and to demonstrate animations. And third, to inspire. As there has been some interest in the construction of the demo, this article is an overview to how the demo was constructed. Before I go into any detail, it is worth noting that this demo was put together without really knowing how much time would have been available to work on it. Because of this, the demo progressed through several stages - each playable and a plausible endpoint - before arriving to what it is today. This is reflected in a few places in the source code, either in code that was written with the best of intentions or in code that was written to be the foundation for something that never came to be.

### STRUCTURE

Complex JavaScript programs get messy pretty fast. This is largely because it is impractical to split a JavaScript program across several files. Lack of namespaces and overly verbose language features (like Object.__defineGetter__) probably don't help the matter. [There is a ridiculous amount of information](http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/) on how to organize your code and keep sane. I've yet to fall madly in love with any of these solutions.

Here's what I usually do:  
I start by defining a dummy module using the object notation (I call this the 'header'). Then I monkey patch all of my functions into it. As I add function definitions and the like, I update the module to reflect the expected structure. Function stubs have comments next to them outlining the expected arguments. I don't use a closure to fake a private scope for the module. Instead, the module is organized to keep calls, callbacks, and different sorts of data separate. It makes testing your code much easier. If you want to scare people from touching something, throw some underscores in front of its name.

The program itself is split into several files, grouping code more or less by purpose. [Header.js](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/header.js) contains the module object definition, and the starting point of execution for the game engine. All of the remaining files are appended to the end of this file (the order doesn't really matter). Assembly of the program (as well as minification) is automated via a make file.

The advantages of using this organizational scheme are:

  * The header provides a simple reference and easy visualization of the program's structure.
  * Doesn't do anything clever with language features to make it work.
  * Looks cleaner to me.



The only disadvantage I can think of is that the header must be maintained as the program is written. It isn't easy to tell if the header is maintained well, since the program can still run if function stubs are missing or some of the variables aren't defined.

### GRAPHICS ENGINE

Levels are built using the program [Tiled](http://www.mapeditor.org/), with the level data exported to json. The levels are tiled on a 32x32 grid, which turned out to be a mistake. If I wrote this again, I would go with a 16x16 grid instead, to simplify the conversion of world coordinates [to](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/graphics.js#line58) and [from](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/controls.js#line121) screen space coordinates. This is explained further in the section about the physics engine.

Tile boards are rendered upon two html5 canvas elements; an iframe between the two is where the actors are drawn. Level data may contain more than two layers, but will be automatically flattened into two layers [when the level is rendered](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/map_loader.js#line80). [Actors are represented with div elements](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line80); css is used to [crop and position](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line96) them. For actors inheriting from VisibleKind, [Z-index is used to do depth sorting](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line206), which is why the actors are in an iframe. Depth sorting behavior is done on the actor's _dirty method, [which may be overridden](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line263).

Art assets are fetched in the background by creating a new Image object in JavaScript. The onload callback is used to inform the engine when the resource is ready for use. When the json file for a level is being parsed, [the number of pending downloads is incremented](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/map_loader.js#line243) when an image download is started, [and decremented on its callback](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/map_loader.js#line230). This allows for the program to wait far all of the images to finish downloading [before drawing the tile boards](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/map_loader.js#line232). [A similar technique](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line133) is used with art assets for actors, [but this is unnecessary because the asset is displayed using css](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line98). This is a throwback from when a third canvas element was used to draw the actors.

[The redraw event is scheduled](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/graphics.js#line47) when the focused character's coordinates change (it might still be when any actor's coordinates change, which would be a throwback from when all actors were drawn on a canvas). Because a bunch of functions may request a redraw at once (some might do this multiple times), the first request is honored and the rest are ignored. This simplifies things quite a bit, because the request itself is inexpensive, it can be used when-in-doubt without worrying about a significant performance cost. I'm thinking of generalizing this for another JavaScript game engine I am planning, where there are various engine functions that would make sense to schedule like this. I'm thinking in that version, I'll have the scheduling function be named "please". Eg, please("redraw scene"), etc.

### PHYSICS ENGINE

Physics information is stored on a 16x16 conceptual grid. Originally, this was to be 32x32, but proved to be a mistake: in some cases, this would prevent the character from walking right up to the edge of something. Because many hours of work already spent building levels would be lost by making the whole engine use a 16x16 grid, I opted for a flimsy workaround. Physics info for tiles is now one of A, N, NE, E, SE, S, SW, W, NW; [which describes the wall coverage in a given graphical tile's conceptual subtiles](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/map_loader.js#line100).

The physics grid is populated during level load. [Several](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/controls.js#line32) [helper](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/controls.js#line42) [functions](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/controls.js#line71) [exist](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/controls.js#line82) to check if a given coordinate is blocked by a wall, an actor, or a warp point.

Actors that prototype AnimateKind (which also happens to be the actors which can be the focused player) have a [_move_to function](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line384) that initiates [the walk cycle](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line415). The walk cycle function is probably the most complex singular part of the game engine. This is in part due to the fact that the character's coordinates are floating point values, not array indices. [A good chunk of this code](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line424) is used to make sure the character doesn't appear to be walking through walls when cutting around a corner; this had the added side effect of the movement trajectory appearing to be adaptive to obstructions despite the lack of a real path finding algorithm. Part of the complexity of this function also comes from the fact that it is possible [to call events on other actors when colliding into them](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line467).

The player character is an actor. Any actor that prototypes AnimateKind can be focused as the main character. This is used in the demo a bit, allowing you to play as Alice ([by default](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/header.js#line147)), Bobby Tables, [and a secret character](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/dynamics/secret1.json.js). Using a JavaScript debugger [and a little know-how](http://pastebin.com/vGcsnRJY), you can take control of many other actors; such as any of the students or any of the monsters.

### ACTOR MODEL

Each entity in gameplay is represented by a javascript object that contains data describing the actor, and event handler functions. Actor objects are stored in LPCD.ACTORS.registry, and there exists [several helper functions](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line580) to be used to manage them. If you use the api [functions](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/api.js#line72) to [create](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/api.js#line97) [your](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/api.js#line106) [actors](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/api.js#line115), this process is entirely automatic.

There is an inheritance chain used in creating an actor, allowing different engine features to be implemented on the actors themselves while keeping the code isolated. This means that the code for things like human characters, monsters, treasure boxes, and etc are all responsible for rendering themselves in the graphics engine. These actor type constructors can be found on the header object in [LPCD.ACTORS](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/header.js#line54), and defined in the file [actor_model.js](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js). For the most part, these constructors are fairly concise, with the exceptions of VisibleKind and AnimateKind.

All actors inherit from [AbstractKind](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line31). The most important aspect of this actor is the variable "_binding", which determines if an actor is cleared from memory or not when a new level is loaded. This allows focused actors to travel from level to level. There was going to be a feature for persistent actors, allowing for things like items and treasure, though this was never implemented. Thus, [PersistentKind](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line68) exists, though I don't believe anything actually uses it.

[VisibleKind](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line80) inherits from AbstractKind and is used to provide a presence for the actor in the graphics engine [by creating a div element](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line119) and [inserting it into the iframe](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line180) used to display actors. This object also provides world coordinates (since they're needed for drawing) to the actor. This object does not make an actor responsive to collision detection.

[ObjectKind](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line221) inherits from VisibleKind, and is used for inanimate objects. It provides the [_blocking function](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line255), so that the actor can be used in the physics system.

[AnimateKind](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line282) inherits from ObjectKind. It provides the [_gain_input_focus](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line303) function, [directional facing information](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line355), a [_look_at](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line364) function, and the walk cycle via the [_move_to](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line384) function. This does not implement any animation features, but is simply for animate objects. [CritterKind](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line509) and [HumonKind](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/actor_model.js#line553) both inherit from AnimateKind and implement animation specific features.

### LEVEL SCRIPTING AND CHARACTER DEFINITIONS

Level scripts are found in the [dynamics folder](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/trees/code_freeze/source/static/demogame/dynamics), and have the file name of the level they correspond to + ".js". So for example, the starting level's file name is "start1.json" (level data is found in the [levels folder](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/trees/code_freeze/source/static/demogame/levels). I **do not** recommend viewing it via web browser), the corresponding dynamics script is "[start1.json.js](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/dynamics/start1.json.js)". To make it easy to clean things up when the level changes; when the level is loaded, [an iframe is created and the level dynamics script is loaded within that iframe](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/map_loader.js#line155). It is [given access to LPCD.API](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/map_loader.js#line167) via a global variable named API; but is left blind to the rest of the engine. This allows us to dispose of the script easily [by deleting the iframe](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/graphics.js#line38).

An amusing side effect of this is if you define within a dynamics script an actor that inherits from AnimateKind, and change your input focus to this new actor and leave the level; the object for the actor remains, but none of its member functions may be called anymore. However, anything in the prototype chain still works fine provided that it was defined in the engine itself. Because of this, [characters.js](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/characters.js) is used to define game-specific characters and useful objects outside of the levels and [instance them from the level dynamics script](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/dynamics/house1.json.js#line6) via [the API.instance function](https://gitorious.org/liberated-pixel-cup/lpc_styleguide/blobs/code_freeze/source/static/demogame/js/api.js#line72). Because the code was defined outside of the level, the object remains functional after the level has been flushed.

Conveniently, this behavior is consistent between Firefox and Chrome. If this behavior for scripts in iframes is standardized, I imagine this was never an intended use case.

### CLOSING THOUGHTS

Overall, I'm quite pleased with how the demo turned out. There are some rough spots where it isn't clear where things are happening (eg, flushing the level actors by changing the innerHTML property of a DOM element), which I had forgotten about prior to writing this article. Despite that, I think the code is pretty usable as a game engine, and should still be fairly easy to extend. Hopefully this article serves as a guide for others to tinker with the engine, to use the code in their own projects, or even to study in building something entirely new.

---
pub_date: 2012-07-10
